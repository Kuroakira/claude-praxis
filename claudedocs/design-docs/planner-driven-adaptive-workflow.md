# Planner駆動型アダプティブワークフローアーキテクチャ

## 概要

claude-praxisは現在、固定フェーズ型オーケストレーションを採用している。各コマンドが事前に決められたフェーズ列と固定のエージェントディスパッチ（常に4リサーチャー、常に4レビュアー）を定義する形式だ。本設計は、**プランナー駆動型アダプティブワークフロー**への進化を提案する。単一のワークフロープランナーが — 呼び出し元コマンドからドメイン固有のコンテキストを受け取り — タスク内容とステージに基づいて共有カタログからエージェントを動的に選択し、各タスクの実際のニーズに合ったチーム規模を実現する。

## コンテキストとスコープ

### 固定オーケストレーションのギャップ

claude-praxisのコマンドは現在、オーケストレーションをハードコードしている：

- `/design`は常に4つのリサーチエージェント（Problem Space、Scout、Best Practices、Devil's Advocate）をディスパッチし、その後常に4つのレビューエージェント（Architecture、User Impact、Writing Quality、Devil's Advocate）をディスパッチする
- `/implement`は常にScoutを実行し、その後常に4つの最終レビュアー（Spec Compliance、Code Quality、Security+Performance、Devil's Advocate）をディスパッチする
- `parallel-review-team`スキルは正確に3つの固定設定（`code-review`、`document-review`、`spec-review`）を持ち、それぞれ正確に4人のレビュアーで構成される

このアーキテクチャは機能している — 固定ディスパッチが計測上の障害を引き起こした事実はない。しかし、方向性としての懸念は明確だ：タスク内容に関係なく同一のチーム構成を適用するため、シンプルなタスクには不必要な調整オーバーヘッドがかかり、複雑なタスクには専門的なカバレッジが不足する可能性がある。軽微なドキュメント更新がアーキテクチャ再設計と同じ4レビュアーチームを受ける。よく知られたライブラリの調査が未知の問題領域の探索と同じ4エージェントチームを展開する。この懸念を実際の使用データで検証することは移行計画（Phase 1）に含まれている。

### マルチエージェントオーケストレーションの現状

マルチエージェントオーケストレーション分野は3つのパターンに収束しており、それぞれプロダクションで検証されている：

1. **階層型スーパーバイザー**（CrewAI、LangGraph、Microsoft Agent Framework）：中央のマネージャーがタスクを分解し、固定カタログからワーカーをディスパッチする。プロダクション実績があるが、調整のボトルネックが生じる。
2. **手続き的/SOP型**（MetaGPT、ChatDev）：標準作業手順に従うテンプレート駆動の分解。決定的でトークン効率が良いが、新規タスクには柔軟性に欠ける。
3. **Anthropicオーケストレーター・ワーカー**（Claude Code Agent Teams）：リードエージェントがP2P通信で独立して作業するチームメイトを調整する。Claude Codeネイティブであり、Anthropicのマルチエージェントリサーチシステムで検証済み（シングルエージェントに対して90.2%のパフォーマンス向上）。

研究はまた重大なリスクも明らかにしている：仕様の曖昧さがマルチエージェント障害の41.77%、調整オーバーヘッドが36.94%を占め、マルチエージェントのトークンコストはベースラインの8-17倍に達する。これらの知見が設計上の制約を直接形作っている。

### ビジョン

当面の目標は、レビュアーとリサーチャーの動的選択である。より広いビジョンとしては、**すべてのタスク** — レビューやリサーチだけでなく — が最終的にきめ細かなカタログ駆動の作業単位に分解され、プランナーが各単位に最適なエージェントを割り当てて実行を調整する形を目指す。

## Goals / Non-Goals

### Goals

- タスク内容を分析し共有カタログからエージェントを動的に選択する**ワークフロープランナー**（呼び出し元コマンドからドメインコンテキストを注入）
- 各エントリが独立した検証ソースを持つ**共有カタログ**（レビュアー、リサーチャー）
- **段階的レビュー深度**：ステージ依存のレビュー強度（中間ステージで1-2、最終で3-4）
- **因果的ステップ依存**：各ステップの出力が次のステップの必須入力（チェックリスト遵守ではない）
- **明示的な選択理由**：プランナーのエージェント選択とその根拠が可視的

### Non-Goals

- **完全自律的なフェーズ発明**：プランナーはコマンド定義のガードレール内で動作し、アドホックなワークフロー作成は行わない
- **リアルタイム動的エージェント発見**：カタログは静的に定義され、選択のみが動的
- **レイヤーアーキテクチャの置換**：Command/Skill/Agent/Rule/Hookレイヤーは保持
- **フレームワークの全面書き換え**：これは漸進的な進化であり、既存システムの置換ではない

## 提案

### 設計原則：制約付き動的オーケストレーション

核となる原則は**制約付き動的** — 現在の固定パイプラインと完全動的オーケストレーションの中間地点である。

**なぜ完全固定ではないのか？** 現在のアーキテクチャはタスク内容に関係なく同一のチーム構成を適用する。シンプルなドキュメント修正がアーキテクチャ変更と同じ4レビュアーの扱いを受ける。これはトークンを浪費し（並列エージェントディスパッチあたり8-17倍のコスト）、品質に見合わないレビュー疲労を生む。

**なぜ完全動的ではないのか？** 研究によると、完全動的オーケストレーション — プランナーがフェーズを発明し、エージェントを自由に選択し、フローを制御する — は、仕様の曖昧さ（41.77%の障害率）、プランナーのハルシネーション（存在しないエージェントの選択）、予測不可能なコストに悩まされる。明確に定義された反復可能なワークフローでは、固定パイプラインが完全動的を上回る。

**制約付き動的モデル**：コマンドは引き続きフェーズ構造（何がどの順序で必ず起こるか）を定義する。各フェーズ内で、プランナーが実行方法を決定する — 型付きカタログから選択して、どのエージェントをディスパッチするか、何人のレビュアーを関与させるか、どのリサーチを追求するか。コマンドがガードレールを提供し、プランナーが判断を提供する。

これにより、決定的なフェーズ進行の利点（監査可能性、予測可能なフロー）を維持しつつ、コンテキストに応じたエージェント選択の柔軟性（適正規模のチーム、適切な深度）を追加する。

### 変更点

| 側面 | 現在 | 提案 |
|------|------|------|
| **フェーズ順序** | コマンドで固定 | コマンドで固定のまま（変更なし） |
| **エージェント選択** | フェーズごとに固定（常に4リサーチャー、常に4レビュアー） | プランナーが内容とステージに基づきカタログから選択 |
| **レビュー深度** | 常に4レビュアー | ステージと内容に応じて1-4レビュアー |
| **リサーチ範囲** | 常に4リサーチエージェント | プランナーが関連するリサーチャーを選択（1-4） |
| **選択理由** | 暗黙的（ハードコード） | 明示的（プランナーが各エージェントの選択/省略理由を記述） |
| **コマンド** | フェーズ＋エージェントディスパッチを定義 | フェーズ＋制約を定義＋プランナーを呼び出し |
| **スキル** | `parallel-review-team`（3つの固定タイプ） | `dispatch-reviewers`（カタログベースの選択） |

### 共有カタログ

2つのカタログがプランナーの選択プールを提供する。各カタログエントリは独立した検証ソースを含む — 特化が価値を持つかどうかの基準である（過去の学び：「エージェント特化は各エージェントが独立した検証ソースを持つ場合のみ有効」）。

**レビュアーカタログ**：各ステージでアウトプットを評価するスペシャリスト。

| ID | フォーカス | 独立検証ソース | 適用ドメイン |
|----|-----------|---------------|-------------|
| `architecture` | 設計原則、システム境界、パターン適合性 | アーキテクチャリサーチ、OSSリファレンス実装 | design, implement |
| `spec-compliance` | 仕様と実装の一致性 | Design Doc / FeatureSpecを信頼の源泉とする | implement |
| `document-quality` | 構造、用語、抽象→具体の流れ | プロジェクトのドキュメント品質ルールとDesign Docフォーマットルール | feature-spec, design |
| `code-quality` | TDD遵守、型安全性、パターン | プロジェクトのコード品質ルールとコードベースの慣習 | implement |
| `security-perf` | OWASP、パフォーマンスプロファイリング、リソース使用量 | セキュリティリサーチ＋プロファイリングツール | implement |
| `error-resilience` | 異常系パス、障害モード、グレースフルデグラデーション | プロダクション障害パターン、カオスエンジニアリング原則 | implement |
| `devils-advocate` | 反証、エッジケース、障害パターン | 障害事例研究、アンチパターン文献 | all（最終レビューで必須） |
| `requirements` | ユーザージャーニー、エッジケース、シナリオ網羅性 | ユーザーストーリー、ドメイン分析 | feature-spec |
| `feasibility` | 実装の複雑さ、コードベースの制約 | コードベース探索（Scoutの知見） | feature-spec, design |
| `user-impact` | UX、アクセシビリティ、後方互換性 | UXリサーチ、アクセシビリティ標準 | design |

**`error-resilience`と`devils-advocate`の違い**：`devils-advocate`は「この設計/実装は根本的に間違っていないか？」という方向性の反証を担う。`error-resilience`は方向性が正しい前提で「正常系しか実装されていないのでは？」という実装の網羅性を担う。AIが生成するコードは正常系では完璧に動作するがプロダクション環境で壊れやすい傾向がある — DB接続断で「認証失敗」を返す（正しくは「サービス利用不可」）、リトライストームの防止がない、サーキットブレーカーがない、エラーの区別なく一律に処理する、といったパターンを検出する。検証ソースが異なる（障害事例研究 vs プロダクション障害パターン/カオスエンジニアリング）ため、独立したエントリとして成立する。

**リサーチャーカタログ**：調査フェーズで情報を収集するスペシャリスト。

| ID | フォーカス | エージェント種別 | 独立検証ソース | 適用ドメイン |
|----|-----------|----------------|---------------|-------------|
| `oss-research` | ライブラリ比較、外部ドキュメント、エコシステム分析 | researcher | パッケージレジストリ、公式ライブラリドキュメント、GitHubリポジトリ | design, debug |
| `codebase-scout` | 既存パターン、統合ポイント、制約 | scout | ソースコード自体（読み取り専用探索） | design, implement, debug |
| `domain-research` | 問題領域、先行事例、ドメイン概念 | researcher | 学術論文、ドメイン専門家のブログ、リファレンスアーキテクチャ | design, feature-spec |
| `best-practices` | 業界標準、公式ドキュメント、リファレンス実装 | researcher | 公式ドキュメント、標準仕様 | design, implement |
| `counter-research` | 反証例、障害事例、進めるべきでない理由 | researcher | ポストモーテム記事、Issueトラッカー、障害事例研究 | design |

**フェーズスコープ可視性**：カタログの成長に伴う決定麻痺を防ぐため、プランナーは自身のドメインに関連するエントリのみを参照する。「適用ドメイン」列がフィルターとして機能する。feature-specのプランナーはレビュアーカタログから`requirements`、`document-quality`、`feasibility`、`devils-advocate`を参照するが、`code-quality`や`security-perf`は参照しない。

**将来の拡張**：カタログモデルはきめ細かなマルチエージェント調整のビジョンが成熟するにつれ、タスクカタログ（ライティング、編集、テスト、デプロイ）に自然に拡張できる。同じパターン — 独立検証ソースを持つ型付きエントリ、フェーズスコープ可視性、プランナー駆動選択 — が適用される。

### ワークフロープランナー

単一の`workflow-planner`スキルが4つのドメインすべてを処理する。呼び出し元コマンドがドメイン固有の判断ガイドラインとカタログスコープを注入し、プランナースキル自体はドメイン非依存に保つ。

**なぜ1つのプランナーで4つではないのか？** プランナーのコアロジックは全ドメインで共有される：タスク記述の解析、フェーズスコープ可視性を使ったカタログからのエージェント選択、ステップ依存計画の生成、段階的レビューティアの適用。ドメイン固有の部分は判断ガイドライン（エージェントの追加/削除タイミング）であり、コマンドの呼び出しパラメータで注入できる程度に小さい。4つの別個のプランナーは共有インフラ（プランナーロジックの約80%）を重複させ、カタログやステップフォーマットが進化する際のメンテナンス負荷を生む。ドメインの分岐が注入で扱える範囲を超えた場合、別個のプランナーへの分割は容易に行える。

**ドメインコンテキストの注入方法：**

各コマンドがプランナー呼び出し時にドメイン固有のコンテキストを渡す：

| コマンド | 注入されるドメインコンテキスト | カタログスコープ | 典型的な判断例 |
|---------|---------------------------|----------------|--------------|
| `/feature-spec` | 要件収集、ギャップ分析、インタビュー技法 | レビュアー: requirements, document-quality, feasibility, devils-advocate。リサーチャー: domain-research, codebase-scout | 「要件がエッジケースで曖昧→ドラフト段階でrequirementsレビュアーを追加」 |
| `/design` | リサーチ戦略、アーキテクチャパターン、ドキュメント構造 | レビュアー: architecture, document-quality, feasibility, user-impact, devils-advocate。リサーチャー: 全て | 「新規技術選定→counter-research + oss-researchを追加。既知パターン→codebase-scout + best-practicesのみ」 |
| `/implement` | タスク分解（PR単位）、依存関係分析、TDD | レビュアー: spec-compliance, code-quality, security-perf, devils-advocate。リサーチャー: codebase-scout, best-practices | 「セキュリティに敏感な変更→タスクごとのレビューにsecurity-perfを追加。内部リファクタ→code-qualityのみ」 |
| `/debug` | 再現戦略、仮説形成、証拠収集 | レビュアー: code-quality, devils-advocate。リサーチャー: codebase-scout, oss-research, best-practices | 「3つ以上の競合仮説→並列調査エージェント。単一仮説→逐次検証」 |

**プランナーの出力形式**：プランナーは明示的な計画を生成する — ステップの列であり、各ステップに入力（前ステップからの出力）、割り当てエージェント、期待される出力、レビュー深度の理由が含まれる。これは因果依存の要件を満たす：計画構造自体が各ステップの存在理由と供給先をエンコードする。

**implementにおけるタスク分解の粒度**：

implementプランナーはタスクを**PR単位（目安：約500行の変更）** に分解する。これはコードレビューの有効性に関する研究知見に基づく制約である。

なぜ500行なのか：
- コードレビュー研究（Cisco Systems、SmartBear）は、200-400行を超えるレビューで欠陥検出率が急激に低下することを示している。500行は「1つのPRとしてレビュー可能な上限」の目安
- 小さすぎるタスク（50行未満）はコンテキスト共有コストがレビュー利益を上回る
- 大きすぎるタスク（1000行超）はレビュアーの注意力が分散し、形骸的な承認（rubber-stamping）を招く

プランナーの分解判断：
- Design Docの各設計判断を独立したPR単位にマッピングする
- 依存関係のあるタスクは順序を保証し、独立したタスクは並列実行を検討する
- 500行を大きく超える場合はさらに分割する（例：「モデル層」「API層」「テスト」に分ける）
- 50行未満の些細な変更は隣接タスクに統合する

これにより、各タスクの成果物が「レビュー可能で、マージ可能で、ロールバック可能」な単位になる。最終レビュー（Thorough）は全タスクの統合を対象とするが、タスクごとのLight/Thoroughレビューは各PR単位に対して実行される。

### ステップ依存モデル

プランナーの出力における各ステップは、**因果依存**を通じて前のステップと接続される — ステップNの出力がステップN+1の必須入力となる。この構造はチェックリスト遵守（テンプレートセクションの穴埋め）を防ぎ、各ステップが意味のある成果物を生成することを保証する。

**なぜ因果依存が重要なのか**：過去の経験から、テンプレートベースの遵守（セクション記入の要求）はもっともらしいが低品質なコンテンツで充足できることが分かった。ステップNの出力がステップN+1の明示的な入力である場合、システムはステップNに使用可能なデータの生成を構造的に要求する。ステップNが失敗すればステップN+1は進行できない — 障害は即座に検出され、隠されない。

**Conceptual** なステップ構造：

```
Step:
  name: [説明的な名前]
  requires: [前ステップからの出力]
  agents: [カタログから選択、選択理由付き]
  produces: [下流ステップが消費する出力]
  review_depth: [none | light (1-2) | thorough (3-4)]
  review_reasoning: [このステージでこの深度を選んだ理由]
```

例えば、designワークフローでは：
- Step 1（リサーチ）が発見と矛盾を含むリサーチ統合を**生成する**
- Step 2（アウトライン）がリサーチ統合を**必要とし**、構造化されたアウトラインを**生成する**
- Step 3（アウトラインレビュー）がアウトラインを**必要とし**、具体的な問題点を含むフィードバックを**生成する**
- Step 4（執筆）がアウトライン＋レビューフィードバックを**必要とし**、完全なDesign Docを**生成する**
- Step 5（最終レビュー）がDesign Docを**必要とし**、承認または修正要求を**生成する**

### 段階的レビューモデル

レビュー深度はステージと重要度に応じてスケールし、一律には適用されない。

**3つのレビューティア**：

| ティア | 深度 | 使用時 | レビュアー数 | Devil's Advocate |
|-------|------|-------|-------------|-----------------|
| **None** | 正式レビューなし | 中間成果物（リサーチノート、作業ドラフト） | 0 | いいえ |
| **Light** | 1-2次元に焦点を当てた確認 | ドラフト/アウトライン段階、低リスクの中間ステップ | 1-2 | オプション |
| **Thorough** | 多次元的、包括的 | 最終出力、高リスクの決定、人間向け成果物 | 3-4 | 必須 |

**レビュー深度のプランナー判断ガイドライン**：
- 修正予定の中間成果物 → **None**または**Light**
- 次の主要フェーズに直接供給される出力 → **Light**（構造的問題を早期に検出）
- 最終成果物または不可逆的な決定 → **Thorough**（包括的なカバレッジ）
- セキュリティに敏感またはアーキテクチャに影響する変更 → ステージに関係なく**Thorough**

**ワークフロー別の適用例**：

designワークフロー：

| ステップ | ティア | レビュアー | 理由 |
|---------|-------|-----------|------|
| リサーチ統合 | None | — | アウトラインの入力素材。アウトラインで再構成される |
| アウトライン | Light | document-quality + devils-advocate | 構造的問題を本文執筆前に検出。方向性の誤りを早期発見 |
| 本文完成 | Thorough | architecture + document-quality + devils-advocate（＋必要に応じてuser-impact） | 最終成果物。人間に提示される前の品質ゲート |

implementワークフロー：

| ステップ | ティア | レビュアー | 理由 |
|---------|-------|-----------|------|
| Scout調査結果 | None | — | 計画策定の入力素材。計画に統合される |
| 計画策定 | Light | spec-compliance | Design Docとの整合性を確認。計画のずれを実装前に検出 |
| タスクごとのTDD実装（内部リファクタ） | Light | code-quality | TDDサイクル内の品質確認。セキュリティ影響なし |
| タスクごとのTDD実装（API変更/認証系） | Light〜Thorough | code-quality + security-perf | セキュリティ境界に触れる変更。リスクに応じて深度を上げる |
| タスクごとのTDD実装（外部依存/インフラ接続） | Light〜Thorough | code-quality + error-resilience | DB接続、外部API呼び出し、メッセージキュー等。正常系のみの実装を防ぐ |
| 最終レビュー | Thorough | spec-compliance + code-quality + security-perf + devils-advocate（＋必要に応じてerror-resilience） | 全実装の統合品質ゲート。構造的フロア（3+DA）が適用される |

feature-specワークフロー：

| ステップ | ティア | レビュアー | 理由 |
|---------|-------|-----------|------|
| インタビュー結果整理 | None | — | ドラフトの入力素材 |
| ドラフト | Light | requirements + devils-advocate | 要件の抜け漏れと前提の誤りを早期検出 |
| 最終版 | Thorough | requirements + feasibility + document-quality + devils-advocate | 設計フェーズへの入力。不完全な要件がDesign Docに伝播しないようにする |

debugワークフロー：

| ステップ | ティア | レビュアー | 理由 |
|---------|-------|-----------|------|
| 再現手順 | None | — | 仮説形成の入力素材 |
| 仮説検証結果 | Light | devils-advocate | 確証バイアスの防止。反証の見落としを検出 |
| 調査報告書 | Thorough | code-quality + devils-advocate（＋必要に応じてsecurity-perf） | implementへの入力。誤った根本原因分析が誤った修正につながることを防ぐ |

これらは典型的なパターンであり、プランナーはタスク内容に応じて調整する。例えば、implementでセキュリティに無関係な変更ならタスクごとのレビューから`security-perf`を省略し、debugで性能問題の調査なら仮説検証に`security-perf`を追加する

**構造的フロア**：プランナーは最低基準を満たすかどうかではなく、どのレビュアーを選ぶかを決定する。最終レビューはDevil's Advocateを含む3人以上のレビュアーを必要とする — これはコマンドレベルの制約であり、プランナーはオーバーライドできない。プランナーの柔軟性は、タスク内容に基づいて他の2-3人のレビュアーを選ぶことにあり、合計をフロア以下に減らすことではない。

**なぜ常にthoroughではないのか？** 研究によるとマルチエージェントディスパッチで8-17倍のトークンコストがかかる。全ステージに4レビュアーチームを適用するとコスト爆発が起き、品質向上に見合わない。軽い中間レビューは構造的問題を早期に（修正コストが安い段階で）検出し、完全な調整オーバーヘッドなしで済む。段階的レビューの反パターン（軽いレビューをパスしたことによる誤った安心感）は構造的フロアによって緩和される：プランナーは最終ステージでアンダーディスパッチできない。

**「None」ティアの制限**：Noneティアは完全に改訂される中間成果物にのみ適用される。プランナーは成果物が構造的に完全であること（期待されるすべてのセクション/データが存在すること）を検証してから次のステップに渡す — これは正式なレビューではないが、明らかに不完全な出力の伝播を防ぐ。

### 実行モデル

プランナーはコマンド定義のガードレール内で実行し、主要な選択を人間に可視化する。

**自律性の境界**：
- **プランナーが決定**：どのエージェントをディスパッチするか、何人のレビュアーか、どのリサーチを追求するか、フェーズ内のステップ順序
- **コマンドが決定**：フェーズ順序、必須制約（TDD必須、最終レビュー必須、学び確認必須）、人間のインタラクションポイント、最低レビューフロア

**実行フロー**：
1. コマンドがタスク記述、制約、ドメインコンテキストとともにプランナーを呼び出す
2. プランナーがタスク内容を分析し、関連するカタログエントリを参照する
3. プランナーがエージェント選択と理由を含む明示的な計画を生成する
4. **計画が人間に提示される** — プランナーはエージェント選択、レビュー深度の選択、その理由を実行前に提示する。これは承認ゲートではない（人間は承認する必要がない）；透明性ウィンドウである。人間は何が起こるかを見て、方向性が間違っている場合は中断できる
5. プランナーが計画に従ってステップバイステップで実行し、計画通りにエージェントをディスパッチする
6. 各ステップで、プランナーはエージェントの出力を統合してから次に進む
7. 最終ステップで、プランナーは**レビュートレース**（各ステージでどのレビュー深度が適用されたか、なぜか）とともに結果を人間の承認のために提示する

**なぜ計画を可視化するのか？** プロジェクトのコア哲学は「You Own It」 — 人間は自分の成果物における決定を理解し、説明できるべきである。完全自律実行（人間は最終出力のみを見る）はこれを損なう。計画の可視化はスループットを維持（承認ゲート不要）しつつ、人間に情報を提供する。プランナーがセキュリティに敏感な変更で`security-perf`レビュアーをスキップすることを選んだ場合、人間は実行後ではなく実行前にこれを見る。

## 検討した代替案

### 代替案A：拡張固定パイプライン

**アプローチ**：現在の固定フェーズ構造を維持する。`parallel-review-team`の3つのハードコードされたレビュータイプのみをカタログベースの選択に置き換える。コマンドはどのエージェントをディスパッチするかを正確に定義し続ける。

**利点**：変更が最小限。予測可能な動作。プランナーの信頼性リスクなし。

**提案が好ましい理由**：レビュアー選択に対応するが、リサーチャー選択や段階的レビュー深度には対応しない。さらに重要なのは、より広いビジョン（全タスク種別のカタログ駆動マルチエージェント調整）の基盤を作らないことである。代替案Aは価値ある中間ステップであり — Migration Phase 2として含まれている — が、アダプティブオーケストレーションの実現には至らない。

**再検討すべき時**：プランナーの信頼性が実際に低すぎることが判明した場合（ハルシネーションによる選択、不適切な深度選択）、またはMigration Phase 1の計測で現在の固定ディスパッチが意味のある無駄を生んでいないことが分かった場合、代替案Aが安全な着地点となる。移行パスはPhase 2（プランナーなしのカタログベースディスパッチ）が独立して価値を持つように設計されている。

### 代替案B：完全動的オーケストレーション

**アプローチ**：プランナーが完全な自由を持つ — フェーズを定義し、エージェントを選択し、フローを制御し、新しいワークフローステップさえ発明する。コマンド定義のガードレールなし。

**利点**：最大の柔軟性。事前定義された構造なしにあらゆるタスクに適応できる。

**提案が好ましい理由**：研究によるとマルチエージェント障害の41.77%は仕様の曖昧さに起因する。完全動的プランナーは構造的ガードレールを除去することでこのリスクを増幅する。トークンコストが予測不可能になる。実行パスが実行ごとに変化するためデバッグが困難になる。制約付き動的アプローチは監査可能性と予測可能性を維持しつつ、選択の柔軟性を追加する。

**再検討すべき時**：Claudeの計画能力が大幅に向上し（グラウンデッドなツール選択を伴う信頼性の高い複雑な推論）、トークンコストが大幅に低下した場合、完全動的がより実現可能になる。

### 代替案C：4つの別個のドメインプランナー

**アプローチ**：ドメインごとに1つの専用プランナー（feature-spec-planner、design-planner、implement-planner、debug-planner）を用意し、それぞれが独自のドメイン知識、カタログアクセス、判断ガイドラインを含む。

**利点**：各プランナーがより小さく、より焦点を絞ったコンテキストで動作する。ドメイン固有の推論が分離される。モード切替ロジックが不要。

**提案が好ましい理由**：プランナーの責務分析では、約80%の共有ロジック（カタログ選択、ステップフォーマット、レビューティア、制約適用）と約20%のドメイン固有コンテンツ（判断ガイドライン）のみを示す。4つのプランナーは共有インフラを重複させ、カタログやステップフォーマットが進化する際に4つの更新ポイントを作る。注入されたドメインコンテキストを持つ単一プランナーは、より低いメンテナンスコストで同じ特化を実現する。フェーズスコープカタログ可視性がすでにプランナーをドメインに適したエントリに制約している。

**再検討すべき時**：ドメイン固有の計画ロジックがコマンドレベルの注入で表現できる範囲を超えて成長した場合 — 例えば、implement-plannerがdesign-plannerとは根本的に異なるステップオーケストレーションロジック（判断ガイドラインの違いだけでなく）を必要とする場合。

## 横断的関心事

### トークンコスト管理

マルチエージェントディスパッチは大きなトークンオーバーヘッド（リサーチあたりベースラインの8-17倍）を伴う。緩和策：

- **フェーズスコープカタログ**が決定コンテキストを削減（プランナーは関連エントリのみをロード）
- **段階的レビュー**が不必要なディスパッチを削減（中間で1-2、最終で4）
- **コンテキスト分離**（各ディスパッチエージェントに必要なものだけを渡し、会話全体は渡さない）
- **軽量エージェントにHaiku**（scout、researcherはhaikuモデル、レビュアーはメインモデルを継承）

**プランナーオーバーヘッド**：プランナー自体がタスク分析、カタログ参照、計画生成にトークンを消費する。プランナーが少ないエージェントを選択するシンプルなタスクでは、オーバーヘッドが節約に近づくか超える可能性がある。損益分岐点 — プランナーオーバーヘッドがエージェントディスパッチ削減で正当化される地点 — はタスクの複雑さに依存し、Migration Phase 1で計測される。シンプルなタスクが一貫してネットコスト増加を示す場合、プランナーをバイパスして固定ディスパッチを直接使用できる。

非自明なタスクでの期待コスト影響：中間ステージでより少ないエージェントを使用するため、現在の常時4ディスパッチと比較して総トークン使用量が削減される。最終レビューは同等のまま（3-4レビュアー）。

### 信頼性

LLMベースのプランナーは不適切な選択をする可能性がある。緩和策：

- **ホワイトリストとしてのカタログ**：プランナーは既知のエントリからのみ選択できる（ハルシネーションエージェントなし）
- **フェーズスコープ可視性**：プランナーは適用可能なエントリのみを参照（不適切な選択なし）
- **明示的な理由**：プランナーは各エージェントの選択理由を述べなければならない（不適切な推論を検出可能）
- **コマンドからの必須制約**：一部の要件（最終レビュー、TDD、学び確認）はプランナーの判断でオーバーライドできない

### 移行パス

固定からプランナー駆動への移行は段階的に行える：

1. **Phase 1**：レビュアーおよびリサーチャーカタログを参照ドキュメントとして導入する。現在のディスパッチパターン（トークンコスト、レビュー品質）を計測してベースラインを確立する。現在のコマンドは固定ディスパッチを使用し続けるが、カタログエントリを参照する
2. **Phase 2**：動的レビュアーリストを受け入れる`dispatch-reviewers`スキルを実装する。`parallel-review-team`は古い形式のタイプ名をカタログエントリにマッピングする薄いラッパーになる（例：`code-review` → `[spec-compliance, code-quality, security-perf, devils-advocate]`）
3. **Phase 3**：`workflow-planner`スキルを導入する。まず`/design`（最も構造化されたワークフロー）と統合する。コマンドがドメインコンテキストとカタログスコープを渡し、プランナーがエージェント選択を処理する
4. **Phase 4**：残りのコマンド（implement、feature-spec、debug）にプランナー統合を拡張する。ドメインコンテキスト注入が十分か、別個のプランナーへの分割が必要かを評価する

各フェーズは独立して価値があり、可逆である。

## 懸念事項

### プランナーの選択品質

**リスク**：Claudeが特定のタスクに適切なレビュアーを信頼性高く選択できない可能性がある。セキュリティに関するdesignタスクでarchitectureレビュアーをスキップしたり、単純な変更に対して過剰にディスパッチしたりする可能性がある。

**緩和策**：フェーズスコープカタログが選択肢の空間を制限する。明示的な理由記述の要件が不適切な選択を可視化する。コマンドは最低要件を定義できる（例：「最終レビューにはdevils-advocateを含めなければならない」）。

**モニタリング**：プランナーの選択を経時的に追跡する。パターンが出現した場合（例：タスクに関係なく常にすべての利用可能なレビュアーを選択する）、判断ガイドラインを調整する。

### カスケーディングエラーリスク

**リスク**：プランナーが早い段階で誤った選択をした場合（例：重要なリサーチを省略）、下流のステップが不完全な情報の上に構築される。各ハンドオフがエラーを蓄積する。

**緩和策**：因果依存構造が次のステップで**欠落した**出力を検出する（ステップN+1はステップNの出力なしでは進行できない）。これは構造的障害に対する構造的な早期検出である。

**既知の制限**：因果依存は**誤ったまたは不完全な**出力は検出しない。ステップNが重要な発見を省いたリサーチ統合を生成した場合（プランナーが`counter-research`をスキップしたため）、ステップN+1は完全に見えるがバイアスのかかった入力を受け取る。可視化された計画（実行モデル）がこれを部分的に対処する — 人間は`counter-research`が省略されたことを見て、実行前に中断できる。Devil's Advocateを含むthorough最終レビューが、パイプラインを通じて伝播したセマンティックエラーの二次的なキャッチとして機能する。

### カタログメンテナンス

**リスク**：プロジェクトの進化に伴い、カタログエントリが古くなったり、重複したり、管理可能なサイズを超えて成長したりする可能性がある。

**緩和策**：各エントリは明示的な「適用ドメイン」と「独立検証ソース」フィールドを持つ。明確な検証ソースのないエントリはマージまたは削除されるべきである。`/compound`ワークフローにカタログレビューを知識メンテナンスの一部として含めることができる。

### 後方互換性

**リスク**：既存のコマンドが固定タイプで`parallel-review-team`を参照している。ディスパッチメカニズムの変更がすべてのワークフローに影響する。

**緩和策**：段階的移行パス（上記Phase 1-4）。`dispatch-reviewers`は移行期間中、新しい形式（カタログリスト）と古い形式（タイプ名）の両方のパラメータを受け入れることができる。

## レビューチェックリスト

- [ ] アーキテクチャ承認済み
- [ ] トークンコスト影響の評価済み
- [ ] 移行パスの検証済み（ビッグバンカットオーバーなし）
- [ ] カタログエントリが独立検証ソースを保持
- [ ] プランナー制約が必須品質ゲートを保持（TDD、最終レビュー、学び確認）
- [ ] レイヤーアーキテクチャ保持（Command/Skill/Agent/Rule/Hook境界）
